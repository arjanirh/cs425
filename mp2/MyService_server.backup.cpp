// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "MyService.h"
#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::mp2;

class MyServiceHandler : virtual public MyServiceIf {
 public:
  MyServiceHandler() {
    // Your initialization goes here
  }

  void rpc_return_finger_table(std::vector<node_info> & _return) {
	_return = ftable;

	}

  void rpc_find_successor(suc_data& _return, const int32_t key) {
    // Your implementation goes here
    printf("rpc_find_successor\n");
	if(id == my_suc.id){
		_return my_suc;
		return;
	}

	//Check if key is between myid and my_suc
	//inflate successor
	int inflated_suc_id = my_suc.id;
	if(my_suc.id ==0){
		inflated_suc_id = pow(2,m);
	}
		
	if(key>id && key<= inflated_suc_id){
		_return = my_suc;
		return;
	}
	else{
	//ask closest predecessor - go through finger table and 
		//int closest_pre = ftable[ftable.size()-1].id;
		int pre_port = 0;
		struct node_info target_pre;
  		find_predecessor(target_pre, key);

		//Now connect to predecessor and ask for its successor
		boost::shared_ptr<TSocket> socket(new TSocket("localhost", ftable[i].port));
		boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
		boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
		
		MyServiceClient client(protocol);
		transport->open();
		suc_data result;
		client.rpc_find_successor(result, key);
		transport->close();
			
		_return = result;
		return;
		}
		//if not found
		_return = my_suc;
		return;
	}
  }

//Node asks for keys that belong to him
  void rpc_transfer_keys(std::map<int32_t, file_info> & _return, const int32_t key) {
	
	//Go through key table 
	std::map<int32_t, file_info>::iterator it;
	for(it = key_table.begin(); it!= key_table.end(); it++){
		if(it->first <= key){
			//_return.insert(pair<int_32, file_info>(it->first, it->second));
			_return.insert(*it);
			key_table.erase(it);	
		}
	}
	
  }

  void rpc_give_local_successor(suc_data& _return) {
    // Your implementation goes here
    printf("rpc_give_local_successor\n");
	_return = my_suc;
  }

  void find_predecessor(suc_data& _return, const int32_t key) {

	int inflated_key = key;
	if(key<id){		//Tke care of wrap arounds
		inflated_key = key + pow(2,m);
	}
	//
	//Go through finger table and find predecessor
	for(int i=m-1;i>=0;i--){

		int inflated_ftable_id = ftable[i].id;
		if(ftable[i].id < id){
			inflated_ftable_id = ftable[i].id + pow(2,m);
		}

		if((inflated_key >= inflated_ftable_id) && (inflated_ftable_id > id)){
			_return = ftable[i];
			return;
		}
	}
  }


  void rpc_add_file(std::string& _return, const std::string& filename, const std::string& data, const int32_t key) {
	//If listener make call, then first hash filename and then search for right place to insert
	if(key == -1){
		key = hash(filename);
	}
	if(key >my_pred.id && key <=id){
		struct file_info filedata = {filename, data};
		key_table.insert(pair<int_32, file_info>(key, filedata));
		_return = get_ADD_FILE_result_as_string(filename, key, id);
		return;
	}
	//Not my file
	else{
		//local call, no need to connect
		struct node_info target_suc = rpc_find_successor(key);

		//Connect to target_suc.port
		_return = object.rpc_add_file(filename, data, key);
		return;
	}
  }

  void rpc_del_file(std::string& _return, const std::string& filename, const int32_t key) {

	//If listener make call, then first hash filename and then search for right place to insert
	if(key == -1){
		key = hash(filename);
	}

	//If file should be in my key table
	if(key >my_pred.id && key <=id){
		//If key not found
		if(key_table.find(key) == key_table.end()){
			_return = get_DEL_FILE_result_as_string(filename, key, false, -1);
			return;
		}
		//if file found then delete from map
		key_table.erase( key_table.find(key) ); 
		_return = get_DEL_FILE_result_as_string(filename, key, true, id);
		return
	}

	//Not my file
	else{
		//local call, no need to connect
		struct node_info target_suc = rpc_find_successor(key);
		//Connect to target_suc.port
		_return = object.rpc_del_file(filename, key);
		return;
	}

  }

  void rpc_get_file(std::string& _return, const std::string& filename, const int32_t key) {

	//If listener make call, then first hash filename and then search for right place to insert
	if(key == -1){
		key = hash(filename);
	}

	//If file should be in my key table
	if(key >my_pred.id && key <=id){
		//If key not found
		if(key_table.find(key) == key_table.end()){
			_return = get_GET_FILE_result_as_string(filename, key, false, -1, NULL);
			return;
		}
		//if file found then return fdata from map
		struct file_info finfo = key_table.find(key); 
		_return = get_GET_FILE_result_as_string(finfo.name, key, true, id, finfo.data);
		return;
	}

	//Not my file
	else{
		//local call, no need to connect
		struct node_info target_suc = rpc_find_successor(key);
		//Connect to target_suc.port
		_return = object.rpc_get_file(filename, key);
		return;
	}

  }
  void rpc_get_table(std::string& _return, const int32_t key) {

	if(key == id){
		_return = get_GET_TABLE_result_as_string(ftable, m, key, 0, key_table);
		return;
	}
	else{
	struct node_info target_suc = rpc_find_successor(key);
	
	//Connect to target_suc
	_return = object.rpc_get_table(key);
	return;
	}
 
  }

  void rpc_return_key_table(std::map<int32_t, file_info> & _return) {
  	_return = key_table;
  }

  void rpc_return_predecessor(node_info& _return) {
  	_return = my_pre;
  }

  void rpc_notify_of_predecessor(const node_info& new_pre) {
	if(my_pre.id == -1 || (new_pre.id > my_pre.id && new_pre.id < id)){
		my_pre = new_pre;
	}
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<MyServiceHandler> handler(new MyServiceHandler());
  shared_ptr<TProcessor> processor(new MyServiceProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}


// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "MyService.h"
#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::mp2;

class MyServiceHandler : virtual public MyServiceIf {
 public:
  MyServiceHandler() {
    // Your initialization goes here
  }

  void rpc_return_finger_table(std::vector<node_info> & _return) {
	_return = ftable;

	}

  void rpc_find_successor(suc_data& _return, const int32_t key) {
    // Your implementation goes here
    printf("rpc_find_successor\n");
	if(id == my_suc.id){
		_return my_suc;
		return;
	}

	//Check if key is between myid and my_suc
	//inflate successor
	int inflated_suc_id = my_suc.id;
	if(my_suc.id ==0){
		inflated_suc_id = pow(2,m);
	}
		
	if(key>id && key<= inflated_suc_id){
		_return = my_suc;
		return;
	}
	else{
	//ask closest predecessor - go through finger table and 
		//int closest_pre = ftable[ftable.size()-1].id;
		int pre_port = 0;
		struct node_info target_pre;
  		find_predecessor(target_pre, key);

		//Now connect to predecessor and ask for its successor
		boost::shared_ptr<TSocket> socket(new TSocket("localhost", ftable[i].port));
		boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
		boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
		
		MyServiceClient client(protocol);
		transport->open();
		suc_data result;
		client.rpc_find_successor(result, key);
		transport->close();
			
		_return = result;
		return;
		}
		//if not found
		_return = my_suc;
		return;
	}
  }

  void rpc_give_local_successor(suc_data& _return) {
    // Your implementation goes here
    printf("rpc_give_local_successor\n");
	_return = my_suc;
  }

  void find_predecessor(suc_data& _return, const int32_t key) {

	int inflated_key = key;
	if(key<id){		//Tke care of wrap arounds
		inflated_key = key + pow(2,m);
	}
	//
	//Go through finger table and find predecessor
	for(int i=m-1;i>=0;i--){

		int inflated_ftable_id = ftable[i].id;
		if(ftable[i].id < id){
			inflated_ftable_id = ftable[i].id + pow(2,m);
		}

		if((inflated_key >= inflated_ftable_id) && (inflated_ftable_id > id)){
			_return = ftable[i];
			return;
		}
	}
  }

  void rpc_return_key_table(std::map<int32_t, file_info> & _return) {
  	_return = key_table;
  }

  void rpc_return_predecessor(node_info& _return) {
  	_return = my_pre;
  }

  void rpc_notify_of_predecessor(const node_info& new_pre) {
	if(my_pre.id == -1 || (new_pre.id > my_pre.id && new_pre.id < id)){
		my_pre = new_pre;
	}
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<MyServiceHandler> handler(new MyServiceHandler());
  shared_ptr<TProcessor> processor(new MyServiceProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}


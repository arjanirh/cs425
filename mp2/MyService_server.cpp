// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "MyService.h"
#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>
#include <getopt.h>
#include <stdarg.h>
#include <assert.h>
#include <stdlib.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::mp2;

using namespace std;

struct node_info{

	int id;
	int port;
};

struct file_info{

	string name;
	string data;
};

/* Function prototypes */
string get_ADD_FILE_result_as_string(const char *fname, const int32_t key, const int32_t nodeId);
string get_DEL_FILE_result_as_string(const char *fname, const int32_t key, const bool deleted, const int32_t nodeId);
string get_GET_FILE_result_as_string(const char *fname,const int32_t key,const bool found,const int32_t nodeId,const char *fdata);
string get_GET_TABLE_result_as_string(const vector<node_info>& finger_table,const uint32_t m,const uint32_t myid,
											const uint32_t idx_of_entry1,const std::map<int32_t, file_info>& keys_table);
string get_finger_table_as_string(const std::vector<node_info>& table,const uint32_t m,const uint32_t myid, const uint32_t idx_of_entry1);
string get_keys_table_as_string(const std::map<int32_t, file_info>& table);
void check_usage(int);
void parse_args(int argc, char **argv);
void make_asserts();
void setup_successor();
void setup_finger_table();
void setup_key_table();
void setup_listener_thread();
void setup_stabilize_thread();
void setup_fixfinger_thread();

/*	Globals */	
int opt;
int long_index;

int m = -1;
int id = -1;
int port = -1;
int introducerPort = -1;
int stabilizeInterval = 1;
int fixInterval = 1;
int seed = -1;
const char *logconffile = NULL;
 
// My Successor and my predecessor
struct node_info my_suc = { 0, port};
struct node_info my_pre = {-1, -1};

//finger table: a vector of <(id, port)>
vector<node_info> ftable;

//key table: a map
map<int32_t, file_info> key_table; 

pthread_t stabilize_thread;
pthread_t fixfinger_thread;

class MyServiceHandler : virtual public MyServiceIf {
 public:
  MyServiceHandler() {
    // Your initialization goes here
  }

  void rpc_return_finger_table(std::vector<node_info> & _return) {
	_return = ftable;

	}

  void rpc_find_successor(suc_data& _return, const int32_t key) {
    // Your implementation goes here
    printf("rpc_find_successor\n");
	if(id == my_suc.id){
		_return my_suc;
		return;
	}

	//Check if key is between myid and my_suc
	//inflate successor
	int inflated_suc_id = my_suc.id;
	if(my_suc.id ==0){
		inflated_suc_id = pow(2,m);
	}
		
	if(key>id && key<= inflated_suc_id){
		_return = my_suc;
		return;
	}
	else{
	//ask closest predecessor - go through finger table and 
		//int closest_pre = ftable[ftable.size()-1].id;
		int pre_port = 0;
		struct node_info target_pre;
  		find_predecessor(target_pre, key);

		//Now connect to predecessor and ask for its successor
		boost::shared_ptr<TSocket> socket(new TSocket("localhost", ftable[i].port));
		boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
		boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
		
		MyServiceClient client(protocol);
		transport->open();
		suc_data result;
		client.rpc_find_successor(result, key);
		transport->close();
			
		_return = result;
		return;
		}
		//if not found
		_return = my_suc;
		return;
	}
  }

//Node asks for keys that belong to him
  void rpc_transfer_keys(std::map<int32_t, file_info> & _return, const int32_t key) {
	
	//Go through key table 
	std::map<int32_t, file_info>::iterator it;
	for(it = key_table.begin(); it!= key_table.end(); it++){
		if(it->first <= key){
			//_return.insert(pair<int_32, file_info>(it->first, it->second));
			_return.insert(*it);
			key_table.erase(it);	
		}
	}
	
  }

  void rpc_give_local_successor(suc_data& _return) {
    // Your implementation goes here
    printf("rpc_give_local_successor\n");
	_return = my_suc;
  }

  void find_predecessor(suc_data& _return, const int32_t key) {

	int inflated_key = key;
	if(key<id){		//Tke care of wrap arounds
		inflated_key = key + pow(2,m);
	}
	//
	//Go through finger table and find predecessor
	for(int i=m-1;i>=0;i--){

		int inflated_ftable_id = ftable[i].id;
		if(ftable[i].id < id){
			inflated_ftable_id = ftable[i].id + pow(2,m);
		}

		if((inflated_key >= inflated_ftable_id) && (inflated_ftable_id > id)){
			_return = ftable[i];
			return;
		}
	}
  }


  void rpc_add_file(std::string& _return, const std::string& filename, const std::string& data, const int32_t key) {
	//If listener make call, then first hash filename and then search for right place to insert
	if(key == -1){
		key = hash(filename);
	}
	if(key >my_pred.id && key <=id){
		struct file_info filedata = {filename, data};
		key_table.insert(pair<int_32, file_info>(key, filedata));
		_return = get_ADD_FILE_result_as_string(filename, key, id);
		return;
	}
	//Not my file
	else{
		//local call, no need to connect
		struct node_info target_suc = rpc_find_successor(key);

		//Connect to target_suc.port
		_return = object.rpc_add_file(filename, data, key);
		return;
	}
  }

  void rpc_del_file(std::string& _return, const std::string& filename, const int32_t key) {

	//If listener make call, then first hash filename and then search for right place to insert
	if(key == -1){
		key = hash(filename);
	}

	//If file should be in my key table
	if(key >my_pred.id && key <=id){
		//If key not found
		if(key_table.find(key) == key_table.end()){
			_return = get_DEL_FILE_result_as_string(filename, key, false, -1);
			return;
		}
		//if file found then delete from map
		key_table.erase( key_table.find(key) ); 
		_return = get_DEL_FILE_result_as_string(filename, key, true, id);
		return
	}

	//Not my file
	else{
		//local call, no need to connect
		struct node_info target_suc = rpc_find_successor(key);
		//Connect to target_suc.port
		_return = object.rpc_del_file(filename, key);
		return;
	}

  }

  void rpc_get_file(std::string& _return, const std::string& filename, const int32_t key) {

	//If listener make call, then first hash filename and then search for right place to insert
	if(key == -1){
		key = hash(filename);
	}

	//If file should be in my key table
	if(key >my_pred.id && key <=id){
		//If key not found
		if(key_table.find(key) == key_table.end()){
			_return = get_GET_FILE_result_as_string(filename, key, false, -1, NULL);
			return;
		}
		//if file found then return fdata from map
		struct file_info finfo = key_table.find(key); 
		_return = get_GET_FILE_result_as_string(finfo.name, key, true, id, finfo.data);
		return;
	}

	//Not my file
	else{
		//local call, no need to connect
		struct node_info target_suc = rpc_find_successor(key);
		//Connect to target_suc.port
		_return = object.rpc_get_file(filename, key);
		return;
	}

  }
  void rpc_get_table(std::string& _return, const int32_t key) {

	if(key == id){
		_return = get_GET_TABLE_result_as_string(ftable, m, key, 0, key_table);
		return;
	}
	else{
	struct node_info target_suc = rpc_find_successor(key);
	
	//Connect to target_suc
	_return = object.rpc_get_table(key);
	return;
	}
 
  }

  void rpc_return_key_table(std::map<int32_t, file_info> & _return) {
  	_return = key_table;
  }

  void rpc_return_predecessor(node_info& _return) {
  	_return = my_pre;
  }

  void rpc_notify_of_predecessor(const node_info& new_pre) {
	if(my_pre.id == -1 || (new_pre.id > my_pre.id && new_pre.id < id)){
		my_pre = new_pre;
	}
  }

};

int main(int argc, char **argv) {
  //int port = 9090;
  shared_ptr<MyServiceHandler> handler(new MyServiceHandler());
  shared_ptr<TProcessor> processor(new MyServiceProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();

    //INIT_LOCAL_LOGGER();
	
	check_usage(argc);
	parse_args(argc, argv);
	make_asserts();

	// configureLogging(logconffile);     /* if you want to use the log4cxx, uncomment this */
	
	//Node Join:
	setup_server();

	setup_successor();
	setup_finger_table();
	setup_key_table();

	setup_stabilize_thread();			//FIX keys also
	setup_fixfinger_thread();

  return 0;
}

void connect_to_port(int port_to_connect_to){

	boost::shared_ptr<TSocket> socket(new TSocket("localhost", my_suc.port));
	boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
	boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));

	MyServiceClient client(protocol);
    transport->open();
	map<int_32, file_info> newmap;
	client.rpc_transfer_keys(newmap, id);
	transport->close();

}

//ASK suc for keys that belong to me.
// key <=myid
void fixKeys(){

	//Connect to suc.port
	boost::shared_ptr<TSocket> socket(new TSocket("localhost", my_suc.port));
	boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
	boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));

	MyServiceClient client(protocol);
    transport->open();
	map<int_32, file_info> newmap;
	client.rpc_transfer_keys(newmap, id);
	transport->close();

	//Now add the newly recd keys to my map
	map<int_32, file_info>::iterator it;
	key_table.insert(newmap.start(), newmap.end());
}

/*
 * Ask suc for pred, if diff than me, then set, and notify new succ
 */ 
void *stabilize(){
	
	while(1){
		//Connect to suc.port
		
		boost::shared_ptr<TSocket> socket(new TSocket("localhost", my_suc.port));
		boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
		boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
	
		MyServiceClient client(protocol);
   		transport->open();
		struct node_info recd_pre;
		client.rpc_return_predecessor(recd_pre);
		transport->close();
		
		int inflated_suc_id = my_suc.id;
		if(my_suc.id == 0)
			inflated_suc_id = pow(2,m);
		if(recd_pre.id > id && recd_pre.id < inflated_suc_id){
			my_suc = recd_pre;
		}
	
		//Now notify successor that i am your pred
		//Connect to suc.port --NEED THIS AGAIN because suc might have changed in the if case
		boost::shared_ptr<TSocket> socket(new TSocket("localhost", my_suc.port));
		boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
		boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
	
		MyServiceClient client(protocol);
	    transport->open();
		struct node_info my_node_info = {id, port};
		client.rpc_notify_of_predecessor(my_node_info);
		transport->close();
	
		fixKeys();
		//Sleep for an interval
		sleep(stabilizeInterval);
	}

}

// Make thread 
void setup_stabilize_thread(){

	pthread_create(&stabilize_thread, NULL, stabilize, NULL);	

}

//Fix random finger
void *fix_fingers(){

	while(1){
		int finger = rand() % m;
	
		//Ask myself for finding successor for a particular key
		ftable[finger].id = rpc_find_successor(id);		
		sleep(fixInterval);
	}
}

void setup_fixfinger_thread(){

	pthread_create(&fixfinger_thread, NULL, fix_fingers, NULL);	
}

/*
 * if introducer (id=0) 
 * 	then S=0, P=nil
 * else
 * 	find_successor()
 */
void setup_successor(){

	//If introducer then I am my suc
	if(id==0){
		my_suc.id = 0;
		my_suc.port = port;
	}
	else{
		//Ask id0 to find my suc
		boost::shared_ptr<TSocket> socket(new TSocket("localhost", introducerPort));
		boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
		boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
	
		MyServiceClient client(protocol);
	    transport->open();
		client.rpc_find_successor(my_suc, id);
		transport->close();
	}

}


void setup_finger_table(){

	//if introducer then always copy myself m times into ftable
	if(id==0){
		struct node_info entry= { id, port };

		for(int i=0;i<m; i++){
			ftable.push_back(entry);
		}
	}
	else{
		boost::shared_ptr<TSocket> socket(new TSocket("localhost", my_suc.port));
		boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
		boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
	
		MyServiceClient client(protocol);
	    transport->open();
		client.rpc_return_finger_table(ftable);
		transport->close();
		
	}
}

void setup_key_table(){

	if(id==0){
		//ignore
		return;
	}
	else{
		boost::shared_ptr<TSocket> socket(new TSocket("localhost", my_suc.port));
		boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
		boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
	
		MyServiceClient client(protocol);
	    transport->open();
		client.rpc_return_key_table(key_table);
		transport->close();
	}

}


int find_successor_in_local_ftable(){


	return -1;
}

void check_usage(int argc){

	if(argc<4){
		cout<<"Usage: ./node --m --id --port (--introducerPort) (--stabilizeInterval) (--fixInterval) (--seed) (--logConf)\n";
		cout<<"Exiting...\n";
		exit(-1);
	}
}

void make_asserts(){

    assert((m >= 3) && (m <= 10));

    assert((id >= 0) && (id < pow(2,m)));

    assert (port > 0);

	//Seed random number generator
	if(seed == -1){
		srand(time(NULL));
	}
	else{
		srand(seed);
	}
}

void parse_args(int argc, char **argv){

    struct option long_options[] = {
        /* mandatory args */

        {"m", required_argument, 0, 1000},

        /* id of this node: 0 for introducer */
        {"id", required_argument, 0, 1001},

        /* port THIS node will listen on, at least for the
         * Chord-related API/service
         */
        {"port", required_argument, 0, 1002},



        /* optional args */

        /* if not introducer (id != 0), then this is required: port
         * the introducer is listening on.
         */
        {"introducerPort", required_argument, 0, 1003},

        /* path to the log configuration file */
        {"logConf", required_argument, 0, 1004},

        /* intervals (seconds) for runs of the stabilization and
         * fixfinger algorithms */
        {"stabilizeInterval", required_argument, 0, 1005},
        {"fixInterval", required_argument, 0, 1006},

        {"seed", required_argument, 0, 1007},

        {0, 0, 0, 0},
    };


    while ((opt = getopt_long(argc, argv, "", long_options, &long_index)) != -1)
    {

        switch (opt) {
        case 0:
            if (long_options[long_index].flag != 0) {
                break;
            }
            printf("option %s ", long_options[long_index].name);
            if (optarg) {
                printf("with arg %s\n", optarg);
            }
            printf("\n");
            break;

        case 1000:

            m = strtol(optarg, NULL, 10);
            assert((m >= 3) && (m <= 10));
            break;

        case 1001:
            id = strtol(optarg, NULL, 10);
            assert(id >= 0);
            break;

        case 1002:
            port = strtol(optarg, NULL, 10);
            assert(port > 0);
            break;

        case 1003:
            introducerPort = strtol(optarg, NULL, 10);
            assert(introducerPort > 0);
            break;

        case 1004:
            logconffile = optarg;
            break;

        case 1005:
            stabilizeInterval = strtol(optarg, NULL, 10);
            assert(stabilizeInterval > 0);
            break;

        case 1006:
            fixInterval = strtol(optarg, NULL, 10);
            assert(fixInterval > 0);
            break;

        case 1007:
            seed = strtol(optarg, NULL, 10);
            break;

        default:
            exit(1);
        }
    }



}
/*
     * example output:
fname= foo.c
key= 3
added to node= 4

    */      
    string get_ADD_FILE_result_as_string(const char *fname,
                                         const int32_t key,
                                         const int32_t nodeId)
    {
        std::stringstream s;
        s << "fname= " << fname << "\n";
        s << "key= " << key << "\n";
        s << "added to node= " << nodeId << "\n";
        return s.str();
    }

    /*
     * example output:
fname= foo.c
key= 3
file not found

     * example output:
fname= bar.h
key= 6
was stored at node= 0
deleted

    */
    string get_DEL_FILE_result_as_string(const char *fname,
                                         const int32_t key,
                                         const bool deleted,
                                         const int32_t nodeId)
    {
        std::stringstream s;
        s << "fname= " << fname << "\n";
        s << "key= " << key << "\n";
        if (deleted) {
            // then nodeId is meaningful
            s << "was stored at node= " << nodeId << "\n";
            s << "deleted\n";
        }
        else {
            // assume that this means file was not found
            s << "file not found\n";
        }
        return s.str();
    }

    /*
     * example output:
fname= foo.c
key= 3
file not found

     * example output:
fname= bar.h
key= 6
stored at node= 0
fdata= this is file bar.h

     */
    string get_GET_FILE_result_as_string(const char *fname,
                                         const int32_t key,
                                         const bool found,
                                         const int32_t nodeId,
                                         const char *fdata)
    {
        std::stringstream s;
        s << "fname= " << fname << "\n";
        s << "key= " << key << "\n";
        if (found) {
            // then nodeId is meaningful
            s << "stored at node= " << nodeId << "\n";
            s << "fdata= " << fdata << "\n";
        }
        else {
            // assume that this means file was not found
            s << "file not found\n";
        }
        return s.str();
    }

    /* example output (node has 2 files):
finger table:
entry: i= 1, interval=[ 5, 6), node= 0
entry: i= 2, interval=[ 6, 0), node= 0
entry: i= 3, interval=[ 0, 4), node= 0
keys table:
entry: k= 1, fname= 123.doc, fdata= this is file 123.doc data
entry: k= 3, fname= 123.txt, fdata= this is file 123.txt data

     * example output (node has no file):
finger table:
entry: i= 1, interval=[ 1, 2), node= 4
entry: i= 2, interval=[ 2, 4), node= 4
entry: i= 3, interval=[ 4, 0), node= 4
keys table:

    *
    */
    string get_GET_TABLE_result_as_string(
        const vector<node_info>& finger_table,
        const uint32_t m,
        const uint32_t myid,
        const uint32_t idx_of_entry1,
        const std::map<int32_t, file_info>& keys_table)
    {
        return get_finger_table_as_string(
            finger_table, m, myid, idx_of_entry1) + get_keys_table_as_string(keys_table);
    }


/*
 * use this get_finger_table_as_string() function. when asked for its
 * finger table, a node should respond with the string returned by
 * this function.
 */


/* "..." is some struct/class that contains a member "id" as the id of
 * the node pointed to by that entry.
 *
 * myid is the id of the node
 * calling this function.
 */

std::string
get_finger_table_as_string(const std::vector<node_info>& table,
                           const uint32_t m,
                           const uint32_t myid,
                           const uint32_t idx_of_entry1)
{
    std::stringstream s;
    assert(table.size() == (idx_of_entry1 + m));
    s << "finger table:\n";
    for (size_t i = 1; (i - 1 + idx_of_entry1) < table.size(); ++i) {
        using std::setw;
        s << "entry: i= " << setw(2) << i << ", interval=["
          << setw(4) << (myid + (int)pow(2, i-1)) % ((int)pow(2, m))
          << ",   "
          << setw(4) << (myid + (int)pow(2, i)) % ((int)pow(2, m))
          << "),   node= "
          << setw(4) << table.at(i - 1 + idx_of_entry1).id
          << "\n";
    }
    return s.str();
}

/********************************************************/

/*
 * use this get_keys_table_as_string() function. when asked for its
 * keys table, a node should respond with the string returned by this
 * function.
 */


/* "..." is some struct/class that contains members "name" and "data"
 * as the name and data of the file.
 */

std::string
get_keys_table_as_string(const std::map<int32_t, file_info>& table)
{
    std::stringstream s;
    std::map<int32_t, file_info>::const_iterator it = table.begin();
    /* std::map keeps the keys sorted, so our iteration will be in
     * ascending order of the keys
     */
    s << "keys table:\n";
    for (; it != table.end(); ++it) {
        using std::setw;
        /* assuming file names are <= 10 chars long */
        s << "entry: k= " << setw(4) << it->first
          << ",  fname= " << setw(10) << it->second.name
          << ",  fdata= " << it->second.data
          << "\n";
    }
    return s.str();
}

